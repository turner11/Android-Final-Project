package com.finalProject.smstranslator;

public class GoogleTranslator {


	/** 
	 The template for translation requests from google 
	 */
	final String GOOGLE_TRANSLATE_URL_TEMPLATE = "http://translate.google.com/translate_a/t?client=p&hl={0}&sl={1}&tl={2}&ie=UTF-8&oe=UTF-8&multires=1&oc=2&otf=1&ssel=0&tsel=0&pc=1&sc=1&q={3}";


	//"http://translate.google.com/translate_a/t?client=t&hl=iw&sl=auto&tl=iw&ie=UTF-8&oe=UTF-8&multires=1&oc=1&prev=conf&psl=en&ptl=iw&otf=1&it=sel.8772&ssel=3&tsel=6&uptl=iw&alttl=en&sc=1&q=dog"

	//"http://translate.google.com/translate_a/t?client=p&text={0}&hl={1}&sl=en&tl={2}&ie=UTF-8&oe=UTF-8&multires=1&otf=2&ssel=2&tsel=2&sc=1";  

	/** 
	 Initializes a new instance of the <see cref="GoogleTranslator"/> class.
	 */
	public GoogleTranslator()
	{

	}

	/** 
	 Translates the specified word in the context of sentence.

	 @param word The word to translate.
	 @param context The sentence which is the context of the word.
	 @param languageFrom The language to translate from.
	 @param languageTo The language to translate to.
	 @return 
	 the translation of word in context

	 @exception System.ArgumentException Language to translate to was not specified
	 */
	public final TranslationInContextPackage Translate(String word, String context, Language languageFrom, Language languageTo)
	{
		if (languageTo == null)
		{
			throw new IllegalArgumentException("Language to translate to was not specified");
		}
		TranslationInContextPackage retPackage = this.GetTranslationWithContext(word, context, languageFrom, languageTo);
		return retPackage;

	}

	/** 
	 Gets the translation for aword in a context.

	 @param word The word.
	 @param context The context.
	 @param languageFrom The language to translate from.
	 @param languageTo The language to translate to.
	 @return The package containg translation
	 */
	private TranslationInContextPackage GetTranslationWithContext(String word, String context, Language languageFrom, Language languageTo)
	{
		// TODO: document, if nedded, simplify!
		TranslationInContextPackage retPackage = new TranslationInContextPackage();
		retPackage.LaguageFrom = languageFrom;
		retPackage.LaguageTo = languageTo;


		Translation translationSentence = null;

		if (!String.IsNullOrWhiteSpace(context))
		{
			// tanslate a sentence and put words's sentence in array
			translationSentence = this.GetTranslation(context, languageFrom, languageTo);

			retPackage.CopyBaseValues(translationSentence);
		}
		// if we had an error, don't bother
		if (!retPackage.ErrorEncounterd)
		{
			Translation translationWord = null;
			if (!String.IsNullOrWhiteSpace(word))
			{
				translationWord = this.GetTranslation(word, languageFrom, languageTo);
				retPackage.Word = word;
				retPackage.Translations.AddRange(translationWord.Translations);
			}

			if (translationSentence != null)
			{
				//Check if the word we are translating, appers in the tranlated context
				if (translationWord == null)
				{
					retPackage.Word = context;
					retPackage.Translations.AddRange(translationSentence.Translations);
				}
				else
				{


					for (String currWord : translationWord.Translations)
					{
						for (String currContextWord : translationSentence.Translations)
						{
							if (currWord.compareTo(currContextWord) == 0)
							{
								retPackage.BestMatch = currWord;
							}

						}
					}
				}
			}



			//if there was no match in sentence, we should still return a translation
			if (String.IsNullOrWhiteSpace(retPackage.BestMatch) && retPackage.Translations.size() > 0) //only if we have a word we need to get a best match...
			{
				retPackage.BestMatch = retPackage.Translations.<String>First();
			}
		}
		//HACK: this happens when we translate a sentence, it is because we don't undestand the structure yet...
		//C# TO JAVA CONVERTER TODO TASK: There is no Java equivalent to LINQ queries:
		java.util.ArrayList<String> temp = retPackage.Translations.Distinct().ToList();
		retPackage.Translations.Clear();
		retPackage.Translations.AddRange(temp);

		return retPackage;
	}

	/** 
	 Gets the translation for an expression.

	 @param expression The expression.
	 @param languageFrom The language to translate from.
	 @param languageTo The language to translate to.
	 @return the translation
	 */
	private Translation GetTranslation(String expression, Language languageFrom, Language languageTo)
	{
		//Will hold translated values
		Translation translation = null;
		//The translate symbol 
		String languagePairSymbol = "";


		//get the translation
		translation = this.TranslateExpression(expression, languageFrom, languageTo);

		return translation;
	}

	/** 
	 Translates a sentence.

	 @param expression The sentence.
	 @param source The language to translate from.
	 @param target The language to translate to.
	 @param encoding The encoding.
	 @return The translation
	 */
	private Translation TranslateExpression(String expression, Language languageFrom, Language languageTo)
	{
		Translation trans = new Translation(expression);
		Encoding encoding = Encoding.GetEncoding(1255);
		//Getting the url
		String url = GoogleTranslator.GetTranslateUrl(expression, languageFrom, languageTo);

		String reply = "";
		try (WebClient webClient = new WebClient())
		{
			try
			{

				webClient.Encoding = encoding;
				Stream st = webClient.OpenRead(url);
				StreamReader reader = new StreamReader(st);
				reply = reader.ReadToEnd();
			}
			catch (WebException ex)
			{
				trans.ErrorException = ex;
				return trans;
				//TODO: add logging
			}

		}
		if (!tangible.DotNetToJavaStringHelper.isNullOrEmpty(reply))
		{
			trans = this.GetTranslationFromReply(reply);
		}
		else
		{
			//TODO: Add log
		}


		return trans;
	}

	/** 
	 Gets the translation from googles reply.

	 @param reply Googls reply.
	 */
	private Translation GetTranslationFromReply(String reply)
	{
		//this will contain all translations
		JObject jReply = JObject.Parse(reply);
		java.util.ArrayList<String> translations = GetTranslations(jReply);

		Translation translation = new Translation("", translations);

		return translation;
	}

	/** 
	 Gets the the translated word from google reply .

	 @param reply The reply.
	 @return 
	 */
	private String GetWord(JObject reply)
	{

		String word = "";
		java.util.ArrayList<JToken> sentences = reply["sentences"].ToList();
		if (sentences != null && sentences.size() > 0)
		{
			word = (String)sentences.get(0)["trans"];

		}

		return word;
	}

	package tangible;

	//----------------------------------------------------------------------------------------
	//Copyright © 2007 - 2014 Tangible Software Solutions Inc.
	//This class can be used by anyone provided that the copyright notice remains intact.
	//
	//This class is used to simulate some .NET string methods in Java.
	//----------------------------------------------------------------------------------------
	public final class DotNetToJavaStringHelper
	{
		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Substring' when 'start' is a method
		//	call or calculated value to ensure that 'start' is obtained just once.
		//------------------------------------------------------------------------------------
		public static String substring(String string, int start, int length)
		{
			if (length < 0)
				throw new IndexOutOfBoundsException("Parameter length cannot be negative.");

			return string.substring(start, start + length);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET static string method 'IsNullOrEmpty'.
		//------------------------------------------------------------------------------------
		public static boolean isNullOrEmpty(String string)
		{
			return string == null || string.equals("");
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET static string method 'Join' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String join(String separator, String[] stringArray)
		{
			if (stringArray == null)
				return null;
			else
				return join(separator, stringArray, 0, stringArray.length);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET static string method 'Join' (4 parameter version).
		//------------------------------------------------------------------------------------
		public static String join(String separator, String[] stringArray, int startIndex, int count)
		{
			String result = "";

			if (stringArray == null)
				return null;

			for (int index = startIndex; index < stringArray.length && index - startIndex < count; index++)
			{
				if (separator != null && index > startIndex)
					result += separator;

				if (stringArray[index] != null)
					result += stringArray[index];
			}

			return result;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Remove' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static String remove(String string, int start)
		{
			return string.substring(0, start);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Remove' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String remove(String string, int start, int count)
		{
			return string.substring(0, start) + string.substring(start + count);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'TrimEnd'.
		//------------------------------------------------------------------------------------
		public static String trimEnd(String string, Character... charsToTrim)
		{
			if (string == null || charsToTrim == null)
				return string;

			int lengthToKeep = string.length();
			for (int index = string.length() - 1; index >= 0; index--)
			{
				boolean removeChar = false;
				if (charsToTrim.length == 0)
				{
					if (Character.isWhitespace(string.charAt(index)))
					{
						lengthToKeep = index;
						removeChar = true;
					}
				}
				else
				{
					for (int trimCharIndex = 0; trimCharIndex < charsToTrim.length; trimCharIndex++)
					{
						if (string.charAt(index) == charsToTrim[trimCharIndex])
						{
							lengthToKeep = index;
							removeChar = true;
							break;
						}
					}
				}
				if (!removeChar)
					break;
			}
			return string.substring(0, lengthToKeep);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'TrimStart'.
		//------------------------------------------------------------------------------------
		public static String trimStart(String string, Character... charsToTrim)
		{
			if (string == null || charsToTrim == null)
				return string;

			int startingIndex = 0;
			for (int index = 0; index < string.length(); index++)
			{
				boolean removeChar = false;
				if (charsToTrim.length == 0)
				{
					if (Character.isWhitespace(string.charAt(index)))
					{
						startingIndex = index + 1;
						removeChar = true;
					}
				}
				else
				{
					for (int trimCharIndex = 0; trimCharIndex < charsToTrim.length; trimCharIndex++)
					{
						if (string.charAt(index) == charsToTrim[trimCharIndex])
						{
							startingIndex = index + 1;
							removeChar = true;
							break;
						}
					}
				}
				if (!removeChar)
					break;
			}
			return string.substring(startingIndex);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Trim' when arguments are used.
		//------------------------------------------------------------------------------------
		public static String trim(String string, Character... charsToTrim)
		{
			return trimEnd(trimStart(string, charsToTrim), charsToTrim);
		}

		//------------------------------------------------------------------------------------
		//	This method is used for string equality comparisons when the option
		//	'Use helper 'stringsEqual' method to handle null strings' is selected
		//	(The Java String 'equals' method can't be called on a null instance).
		//------------------------------------------------------------------------------------
		public static boolean stringsEqual(String s1, String s2)
		{
			if (s1 == null && s2 == null)
				return true;
			else
				return s1 != null && s1.equals(s2);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadRight' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static String padRight(String string, int totalWidth)
		{
			return padRight(string, totalWidth, ' ');
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadRight' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String padRight(String string, int totalWidth, char paddingChar)
		{
			StringBuilder sb = new StringBuilder(string);

			while (sb.length() < totalWidth)
			{
				sb.append(paddingChar);
			}

			return sb.toString();
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadLeft' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static String padLeft(String string, int totalWidth)
		{
			return padLeft(string, totalWidth, ' ');
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadLeft' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String padLeft(String string, int totalWidth, char paddingChar)
		{
			StringBuilder sb = new StringBuilder("");

			while (sb.length() + string.length() < totalWidth)
			{
				sb.append(paddingChar);
			}

			sb.append(string);
			return sb.toString();
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOf' (char version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOf(String string, char value, int startIndex, int count)
		{
			int leftMost = startIndex + 1 - count;
			int rightMost = startIndex + 1;
			String substring = string.substring(leftMost, rightMost);
			int lastIndexInSubstring = substring.lastIndexOf(value);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring + leftMost;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOf' (string version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOf(String string, String value, int startIndex, int count)
		{
			int leftMost = startIndex + 1 - count;
			int rightMost = startIndex + 1;
			String substring = string.substring(leftMost, rightMost);
			int lastIndexInSubstring = substring.lastIndexOf(value);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring + leftMost;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'IndexOfAny' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static int indexOfAny(String string, char[] anyOf)
		{
			int lowestIndex = -1;
			for (char c : anyOf)
			{
				int index = string.indexOf(c);
				if (index > -1)
				{
					if (lowestIndex == -1 || index < lowestIndex)
					{
						lowestIndex = index;

						if (index == 0)
							break;
					}
				}
			}

			return lowestIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'IndexOfAny' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static int indexOfAny(String string, char[] anyOf, int startIndex)
		{
			int indexInSubstring = indexOfAny(string.substring(startIndex), anyOf);
			if (indexInSubstring == -1)
				return -1;
			else
				return indexInSubstring + startIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'IndexOfAny' (3 parameter version).
		//------------------------------------------------------------------------------------
		public static int indexOfAny(String string, char[] anyOf, int startIndex, int count)
		{
			int endIndex = startIndex + count;
			int indexInSubstring = indexOfAny(string.substring(startIndex, endIndex), anyOf);
			if (indexInSubstring == -1)
				return -1;
			else
				return indexInSubstring + startIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOfAny' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOfAny(String string, char[] anyOf)
		{
			int highestIndex = -1;
			for (char c : anyOf)
			{
				int index = string.lastIndexOf(c);
				if (index > highestIndex)
				{
					highestIndex = index;

					if (index == string.length() - 1)
						break;
				}
			}

			return highestIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOfAny' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOfAny(String string, char[] anyOf, int startIndex)
		{
			String substring = string.substring(0, startIndex + 1);
			int lastIndexInSubstring = lastIndexOfAny(substring, anyOf);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOfAny' (3 parameter version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOfAny(String string, char[] anyOf, int startIndex, int count)
		{
			int leftMost = startIndex + 1 - count;
			int rightMost = startIndex + 1;
			String substring = string.substring(leftMost, rightMost);
			int lastIndexInSubstring = lastIndexOfAny(substring, anyOf);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring + leftMost;
		}

	}

	/** 
Gets the translations from google reply.

@param reply The reply.
@return 
	 */
	private static java.util.ArrayList<String> GetTranslations(JObject reply)
	{
		java.util.ArrayList<String> translations = new java.util.ArrayList<String>();

		if (reply["dict"] != null) //for word
		{
			java.util.ArrayList<JToken> dictionary = reply["dict"].ToList();
			for (int i = 0; i < dictionary.size(); i++)
			{
				if (dictionary.get(i)["terms"] != null)
				{
					java.util.ArrayList<JToken> terms = dictionary.get(i)["terms"].ToList();
					if (terms != null)
					{
						for (int j = 0; j < terms.size(); j++)
						{
							String translation = (String)terms.get(j);
							translations.add(translation);
						}
					}
				}


			}
		}
		else if (reply["sentences"] != null) //for setences
		{

			java.util.ArrayList<String> temp = new java.util.ArrayList<String>();
			java.util.ArrayList<JToken> sentences = reply["sentences"].ToList();
			for (int i = 0; i < sentences.size(); i++)
			{

				if (sentences.get(i)["trans"] != null)
				{
					JToken trans = sentences.get(i)["trans"];
					if (trans != null)
					{
						String translation = (String)trans;
						temp.add(translation);
					}
				}
			}
			String sentanceJoin = tangible.DotNetToJavaStringHelper.join(" ", temp);
			translations.add(sentanceJoin);
		}

		return translations;
	}

	/** 
Gets the translate URL.

@param expression The sentence.
@param source The language to translate from.
@param target The language to translate to.
@return the url for requesting translate
	 */
	private static String GetTranslateUrl(String expression, Language languageFrom, Language languageTo)
	{

		boolean isAutoDetect = languageFrom == null;

		String targetSymbol = languageTo.Symbol;
		String sourceSymbol = isAutoDetect ? "" : languageFrom.Symbol;



		return GetUrlBySymbols(expression, sourceSymbol, targetSymbol);
	}

	/** 
Gets the URL by symbols.

@param expression The expression to translate.
@param sourceSymbol The symbol of source language.
@param targetSymbol The symbol of to source language.
@return the url
	 */
	private static String GetUrlBySymbols(String expression, String sourceSymbol, String targetSymbol)
	{
		// for a parameter called SL in the URL...
		String slParam = String.IsNullOrWhiteSpace(sourceSymbol) ? "auto" : sourceSymbol;

		//this is for passing the expression in encodeURIcomponent format for non english expressions
		String encodedSentene = Uri.EscapeUriString(expression);
		String url = String.format(GoogleTranslator.GOOGLE_TRANSLATE_URL_TEMPLATE, sourceSymbol, slParam, targetSymbol, encodedSentene);
		return url;
	}


	package tangible;

	//----------------------------------------------------------------------------------------
	//Copyright © 2007 - 2014 Tangible Software Solutions Inc.
	//This class can be used by anyone provided that the copyright notice remains intact.
	//
	//This class is used to simulate some .NET string methods in Java.
	//----------------------------------------------------------------------------------------
	public final class DotNetToJavaStringHelper
	{
		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Substring' when 'start' is a method
		//	call or calculated value to ensure that 'start' is obtained just once.
		//------------------------------------------------------------------------------------
		public static String substring(String string, int start, int length)
		{
			if (length < 0)
				throw new IndexOutOfBoundsException("Parameter length cannot be negative.");

			return string.substring(start, start + length);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET static string method 'IsNullOrEmpty'.
		//------------------------------------------------------------------------------------
		public static boolean isNullOrEmpty(String string)
		{
			return string == null || string.equals("");
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET static string method 'Join' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String join(String separator, String[] stringArray)
		{
			if (stringArray == null)
				return null;
			else
				return join(separator, stringArray, 0, stringArray.length);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET static string method 'Join' (4 parameter version).
		//------------------------------------------------------------------------------------
		public static String join(String separator, String[] stringArray, int startIndex, int count)
		{
			String result = "";

			if (stringArray == null)
				return null;

			for (int index = startIndex; index < stringArray.length && index - startIndex < count; index++)
			{
				if (separator != null && index > startIndex)
					result += separator;

				if (stringArray[index] != null)
					result += stringArray[index];
			}

			return result;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Remove' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static String remove(String string, int start)
		{
			return string.substring(0, start);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Remove' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String remove(String string, int start, int count)
		{
			return string.substring(0, start) + string.substring(start + count);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'TrimEnd'.
		//------------------------------------------------------------------------------------
		public static String trimEnd(String string, Character... charsToTrim)
		{
			if (string == null || charsToTrim == null)
				return string;

			int lengthToKeep = string.length();
			for (int index = string.length() - 1; index >= 0; index--)
			{
				boolean removeChar = false;
				if (charsToTrim.length == 0)
				{
					if (Character.isWhitespace(string.charAt(index)))
					{
						lengthToKeep = index;
						removeChar = true;
					}
				}
				else
				{
					for (int trimCharIndex = 0; trimCharIndex < charsToTrim.length; trimCharIndex++)
					{
						if (string.charAt(index) == charsToTrim[trimCharIndex])
						{
							lengthToKeep = index;
							removeChar = true;
							break;
						}
					}
				}
				if (!removeChar)
					break;
			}
			return string.substring(0, lengthToKeep);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'TrimStart'.
		//------------------------------------------------------------------------------------
		public static String trimStart(String string, Character... charsToTrim)
		{
			if (string == null || charsToTrim == null)
				return string;

			int startingIndex = 0;
			for (int index = 0; index < string.length(); index++)
			{
				boolean removeChar = false;
				if (charsToTrim.length == 0)
				{
					if (Character.isWhitespace(string.charAt(index)))
					{
						startingIndex = index + 1;
						removeChar = true;
					}
				}
				else
				{
					for (int trimCharIndex = 0; trimCharIndex < charsToTrim.length; trimCharIndex++)
					{
						if (string.charAt(index) == charsToTrim[trimCharIndex])
						{
							startingIndex = index + 1;
							removeChar = true;
							break;
						}
					}
				}
				if (!removeChar)
					break;
			}
			return string.substring(startingIndex);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'Trim' when arguments are used.
		//------------------------------------------------------------------------------------
		public static String trim(String string, Character... charsToTrim)
		{
			return trimEnd(trimStart(string, charsToTrim), charsToTrim);
		}

		//------------------------------------------------------------------------------------
		//	This method is used for string equality comparisons when the option
		//	'Use helper 'stringsEqual' method to handle null strings' is selected
		//	(The Java String 'equals' method can't be called on a null instance).
		//------------------------------------------------------------------------------------
		public static boolean stringsEqual(String s1, String s2)
		{
			if (s1 == null && s2 == null)
				return true;
			else
				return s1 != null && s1.equals(s2);
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadRight' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static String padRight(String string, int totalWidth)
		{
			return padRight(string, totalWidth, ' ');
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadRight' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String padRight(String string, int totalWidth, char paddingChar)
		{
			StringBuilder sb = new StringBuilder(string);

			while (sb.length() < totalWidth)
			{
				sb.append(paddingChar);
			}

			return sb.toString();
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadLeft' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static String padLeft(String string, int totalWidth)
		{
			return padLeft(string, totalWidth, ' ');
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'PadLeft' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static String padLeft(String string, int totalWidth, char paddingChar)
		{
			StringBuilder sb = new StringBuilder("");

			while (sb.length() + string.length() < totalWidth)
			{
				sb.append(paddingChar);
			}

			sb.append(string);
			return sb.toString();
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOf' (char version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOf(String string, char value, int startIndex, int count)
		{
			int leftMost = startIndex + 1 - count;
			int rightMost = startIndex + 1;
			String substring = string.substring(leftMost, rightMost);
			int lastIndexInSubstring = substring.lastIndexOf(value);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring + leftMost;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOf' (string version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOf(String string, String value, int startIndex, int count)
		{
			int leftMost = startIndex + 1 - count;
			int rightMost = startIndex + 1;
			String substring = string.substring(leftMost, rightMost);
			int lastIndexInSubstring = substring.lastIndexOf(value);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring + leftMost;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'IndexOfAny' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static int indexOfAny(String string, char[] anyOf)
		{
			int lowestIndex = -1;
			for (char c : anyOf)
			{
				int index = string.indexOf(c);
				if (index > -1)
				{
					if (lowestIndex == -1 || index < lowestIndex)
					{
						lowestIndex = index;

						if (index == 0)
							break;
					}
				}
			}

			return lowestIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'IndexOfAny' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static int indexOfAny(String string, char[] anyOf, int startIndex)
		{
			int indexInSubstring = indexOfAny(string.substring(startIndex), anyOf);
			if (indexInSubstring == -1)
				return -1;
			else
				return indexInSubstring + startIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'IndexOfAny' (3 parameter version).
		//------------------------------------------------------------------------------------
		public static int indexOfAny(String string, char[] anyOf, int startIndex, int count)
		{
			int endIndex = startIndex + count;
			int indexInSubstring = indexOfAny(string.substring(startIndex, endIndex), anyOf);
			if (indexInSubstring == -1)
				return -1;
			else
				return indexInSubstring + startIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOfAny' (1 parameter version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOfAny(String string, char[] anyOf)
		{
			int highestIndex = -1;
			for (char c : anyOf)
			{
				int index = string.lastIndexOf(c);
				if (index > highestIndex)
				{
					highestIndex = index;

					if (index == string.length() - 1)
						break;
				}
			}

			return highestIndex;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOfAny' (2 parameter version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOfAny(String string, char[] anyOf, int startIndex)
		{
			String substring = string.substring(0, startIndex + 1);
			int lastIndexInSubstring = lastIndexOfAny(substring, anyOf);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring;
		}

		//------------------------------------------------------------------------------------
		//	This method replaces the .NET string method 'LastIndexOfAny' (3 parameter version).
		//------------------------------------------------------------------------------------
		public static int lastIndexOfAny(String string, char[] anyOf, int startIndex, int count)
		{
			int leftMost = startIndex + 1 - count;
			int rightMost = startIndex + 1;
			String substring = string.substring(leftMost, rightMost);
			int lastIndexInSubstring = lastIndexOfAny(substring, anyOf);
			if (lastIndexInSubstring < 0)
				return -1;
			else
				return lastIndexInSubstring + leftMost;
		}

	}

}
